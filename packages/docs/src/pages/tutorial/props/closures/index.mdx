---
title: Passing Closures
layout: tutorial
---

Component props are serializable so that Qwik can resume and render each component independently. There's a problem though. What if you want to include a callback to a child component? Callbacks are functions that are normally not serializable, but in Qwik they are.

## Serialization

Qwik serializes functions via the `$()` function by first converting them to [Qwik URLs (QRLs)](/docs/advanced/qrl). 

## QRLs

QRLs are serialized forms of a function that Qwik uses to pass functions across serializable boundaries. 

Qwik features a set of convenience APIs which end in `$` that are equivalent to calling `$()` directly.

The following two lines are equivalent:

- **inline**: `<button onClick$={() => alert('click')}/>`
- **explicit**: `<button onClickQrl={$(() => alert('click'))}/>`

The *inline* technique is the most common approach as callbacks are implemented directly on an element. However, sometimes you need to use the *explicit* form to separate where a function is declared from where it is used.

## Declaring callback props

A component can declare a callback in its props by having:

- A property that ends in `Qrl` (as in `goodbyeQrl`)
- The type of the property as `QRL<T>` where `T` is the lazy reference type that the QRL points to (function signature).

The TypeScript compiler automatically creates a `<name>$:T` property for every `<name>Qrl:QRL<T>` property. For example, `helloQrl: QRL<(name: string) => void>` becomes a `hello$: (name: string) => void` property.

This allows the user of `<MyComponent>` to use either the `Qrl` or `$` form as shown here:

```jsx
<MyComponent goodbyeQrl={goodbyeQrl} hello$={() => {...}} />
```

## Using callback props

Notice that `<MyComponent>` is bound either directly to the prop QRL or wraps the QRL prop in another callback.

The following example demonstrates how you can pass the `props.goodbyeQrl` as a reference to the `<button>`.

```jsx
<button onClickQrl={props.goodbyeQrl}>hello</button>
```

Alternatively, you can create a new callback for `<button>` which internally invokes the callback QRL.

```jsx
<button onClick$={async () => {
    await props.helloQrl?.invoke('World');
  }}>good bye</button>
```

This form allows the `<button>` to invoke the callback with custom parameters.

> Notice that the invocation requires `async` and `await` as the QRLs are lazy-loaded.

## Understanding QRLs

Notice that it is only the creator of API that needs to understand QRLs. The user of the API can be oblivious to the fact that callbacks get converted into QRLs and that they need to be invoked by asynchronous means. As long as the user of API sticks to the properties ending in `$` no special knowledge is required.
